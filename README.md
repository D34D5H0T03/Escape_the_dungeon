# Escape_the_dungeon
This is my first project that I completed for my CSE freshman course. It's a text based RPG game inspired by classic D&amp;D table-top game. The contents of the game are still very limited so it can be considered a draft for a real project in the future.  

# Introduction
Escape the Dungeon is a text-based role-playing game (RPG) developed in C, blending narrative-driven exploration with turn-based combat mechanics. Set in a cursed castle overrun by undead horrors, players assume the role of a protagonist who awakens with fragmented memories and must uncover the dungeon’s dark secrets while fighting to survive. The game emphasizes strategic decision-making through class customization, inventory management, and tactical combat. Designed as a console application, it leverages procedural randomness, structured data, and file I/O operations to create an immersive experience reminiscent of tabletop RPGs and classic rogue-likes.

# Key Features
The game offers four distinct classes—Warrior, Rogue, Cleric, and Mage—each with unique stat distributions, starting gear, and narrative flavor. Warriors excel in direct melee combat with high strength and chainmail armor, while Rogues rely on agility and dual-wielding daggers. Clerics balance healing spells with defensive capabilities, and Mages wield elemental magic through a staff. Combat is turn-based, with initiative determined by dice rolls modified by class-specific accuracy. Players can attack, guard to mitigate damage, cast spells (if available), or use consumables like healing potions.
Exploration unfolds across interconnected zones such as sewers, prison blocks, and ritual sites, each populated with randomized enemy encounters. The narrative is enriched through environmental descriptions and a discoverable journal detailing the dungeon’s tragic backstory. A progression system allows players to level up by collecting "souls" from defeated foes, improving stats like strength or intelligence. The game also includes a save/load system to preserve progress and a risk-reward structure where venturing into harder areas yields greater rewards.

# Technical Features
The codebase employs structured data types to manage complex game states. The player struct encapsulates attributes such as health, magic points, inventory, equipped weapons/armor, and spells, while the enemy struct defines enemy behavior with variables for damage ranges, armor class, and souls awarded on defeat. Items, weapons, armor, and spells are represented through dedicated structs (items, weapon, armour, spells), enabling modular design. Functions like Warrior_preset() initialize class-specific stats, and single_combat() handles battle logic, including damage calculation using pseudo-randomized rolls tied to weapon properties and character stats.
File I/O operations are central to the journal system and save/load functionality. The Warden’s journal is dynamically written to and read from a text file using fprintf() and fgets(), while player data is serialized into a binary file (saved_character.dat) via fwrite() and fread(). Input validation is prioritized: the clear_input_buffer() function prevents overflow errors by flushing unwanted characters after scanf() calls, and menus feature robust error handling for invalid choices. Combat mechanics simulate tabletop RPG rules, with armor class (AC) determining hit chances and guarding halving incoming damage.

# Challenges and Solutions
One significant challenge was managing the game’s state across multiple subsystems. The player struct’s complexity—tracking 20 inventory slots, spells, and equipment—required careful memory management and functions like add_item() to handle inventory interactions. Combat balance was another hurdle; enemy stats were iteratively adjusted to prevent trivial or impossible fights, with damage ranges scaled to player level.
Handling user input reliably proved tricky due to C’s scanf() limitations. The solution involved combining fgets() with input sanitization and a loop-based menu system that re-prompts users on invalid entries. For narrative immersion, area-specific functions (e.g., sewers(), ritual_site()) dynamically generate encounters using pseudo-random enemy selection while maintaining logical consistency with the game’s lore.

# Conclusion
Escape the Dungeon demonstrates how structured programming and creative design can deliver a compelling RPG experience within a text-based framework. Its modular architecture allows for easy expansion, such as adding new enemies or areas, while the class system and procedural combat ensure re-playability. Future enhancements could include expanded spell lists, enemy AI behaviors, or a graphical interface. The project underscores the viability of C for game development, balancing low-level control with high-level storytelling and strategic depth. In future I have plans to import this game into RPG MAKER MV or MZ game engine to create an in-depth role-playing game.
